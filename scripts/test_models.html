<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨¡å‹æµ‹è¯•å·¥å…·</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .success { background: #d4edda; border-color: #c3e6cb; color: #155724; }
        .error { background: #f8d7da; border-color: #f5c6cb; color: #721c24; }
        .info { background: #d1ecf1; border-color: #bee5eb; color: #0c5460; }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        
        .log {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§ª YOLOæ¨¡å‹æµ‹è¯•å·¥å…·</h1>
        <p>æ­¤å·¥å…·ç”¨äºæµ‹è¯•TensorFlow.jsæ ¼å¼çš„YOLOæ¨¡å‹æ˜¯å¦èƒ½æ­£å¸¸åŠ è½½å’Œæ¨ç†ã€‚</p>
        
        <div class="test-section info">
            <h3>ğŸ“‹ æµ‹è¯•æ­¥éª¤</h3>
            <ol>
                <li>å¯åŠ¨æœ¬åœ°WebæœåŠ¡å™¨ (ç¡®ä¿æ¨¡å‹æ–‡ä»¶å¯è®¿é—®)</li>
                <li>ç‚¹å‡»"æµ‹è¯•äººè„¸æ£€æµ‹æ¨¡å‹"æŒ‰é’®</li>
                <li>ç‚¹å‡»"æµ‹è¯•é¤ç›˜æ£€æµ‹æ¨¡å‹"æŒ‰é’®</li>
                <li>æŸ¥çœ‹æµ‹è¯•ç»“æœå’Œæ—¥å¿—è¾“å‡º</li>
            </ol>
        </div>
        
        <div class="test-section">
            <h3>ğŸ¯ æ¨¡å‹æµ‹è¯•</h3>
            <button onclick="testFaceModel()">æµ‹è¯•äººè„¸æ£€æµ‹æ¨¡å‹</button>
            <button onclick="testPlateModel()">æµ‹è¯•é¤ç›˜æ£€æµ‹æ¨¡å‹</button>
            <button onclick="testBothModels()">æµ‹è¯•æ‰€æœ‰æ¨¡å‹</button>
            <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        </div>
        
        <div class="test-section">
            <h3>ğŸ“Š ç³»ç»Ÿä¿¡æ¯</h3>
            <div id="systemInfo">åŠ è½½ä¸­...</div>
        </div>
        
        <div class="test-section">
            <h3>ğŸ“ æµ‹è¯•æ—¥å¿—</h3>
            <div id="testLog" class="log">ç­‰å¾…æµ‹è¯•å¼€å§‹...</div>
        </div>
    </div>

    <script>
        let logElement;
        
        function log(message, type = 'info') {
            if (!logElement) {
                logElement = document.getElementById('testLog');
            }
            
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : 'â„¹ï¸';
            const logMessage = `[${timestamp}] ${prefix} ${message}\\n`;
            
            logElement.textContent += logMessage;
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(message);
        }
        
        function clearLog() {
            document.getElementById('testLog').textContent = '';
        }
        
        async function loadSystemInfo() {
            try {
                await tf.ready();
                
                const systemInfo = `
ğŸ–¥ï¸ æµè§ˆå™¨: ${navigator.userAgent.split(' ').slice(-2).join(' ')}
ğŸ§  TensorFlow.jsç‰ˆæœ¬: ${tf.version.tfjs}
âš¡ åç«¯: ${tf.getBackend()}
ğŸ’¾ å¯ç”¨åç«¯: ${tf.engine().backendNames.join(', ')}
ğŸ”§ WebGLæ”¯æŒ: ${tf.getBackend() === 'webgl' ? 'æ˜¯' : 'å¦'}
                `.trim();
                
                document.getElementById('systemInfo').innerHTML = '<pre>' + systemInfo + '</pre>';
                log('ç³»ç»Ÿä¿¡æ¯åŠ è½½å®Œæˆ');
            } catch (error) {
                document.getElementById('systemInfo').innerHTML = '<span style="color: red;">ç³»ç»Ÿä¿¡æ¯åŠ è½½å¤±è´¥: ' + error.message + '</span>';
                log('ç³»ç»Ÿä¿¡æ¯åŠ è½½å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        async function testModel(modelName, modelPath) {
            log(`å¼€å§‹æµ‹è¯• ${modelName} æ¨¡å‹...`);
            
            try {
                // 1. åŠ è½½æ¨¡å‹
                log(`æ­£åœ¨åŠ è½½æ¨¡å‹: ${modelPath}`);
                const startTime = performance.now();
                const model = await tf.loadGraphModel(modelPath);
                const loadTime = performance.now() - startTime;
                
                log(`æ¨¡å‹åŠ è½½æˆåŠŸ (${loadTime.toFixed(2)}ms)`, 'success');
                
                // 2. æ£€æŸ¥æ¨¡å‹ç»“æ„
                const inputShape = model.inputs[0].shape;
                const outputShape = model.outputs[0].shape;
                
                log(`è¾“å…¥å½¢çŠ¶: [${inputShape.join(', ')}]`);
                log(`è¾“å‡ºå½¢çŠ¶: [${outputShape.join(', ')}]`);
                
                // 3. åˆ›å»ºæµ‹è¯•è¾“å…¥
                log('åˆ›å»ºæµ‹è¯•è¾“å…¥å¼ é‡...');
                const testInput = tf.randomNormal([1, 640, 640, 3]);
                
                // 4. æ‰§è¡Œæ¨ç†æµ‹è¯•
                log('æ‰§è¡Œæ¨ç†æµ‹è¯•...');
                const inferenceStart = performance.now();
                const prediction = model.predict(testInput);
                const result = await prediction.data();
                const inferenceTime = performance.now() - inferenceStart;
                
                log(`æ¨ç†æˆåŠŸ (${inferenceTime.toFixed(2)}ms)`, 'success');
                log(`è¾“å‡ºæ•°æ®é•¿åº¦: ${result.length}`);
                log(`è¾“å‡ºæ•°æ®èŒƒå›´: [${Math.min(...result).toFixed(4)}, ${Math.max(...result).toFixed(4)}]`);
                
                // 5. æ¸…ç†èµ„æº
                testInput.dispose();
                prediction.dispose();
                model.dispose();
                
                log(`${modelName} æ¨¡å‹æµ‹è¯•å®Œæˆ âœ…`, 'success');
                log(`æ€»ç”¨æ—¶: ${(performance.now() - startTime).toFixed(2)}ms`);
                
                return true;
                
            } catch (error) {
                log(`${modelName} æ¨¡å‹æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                log(`é”™è¯¯è¯¦æƒ…: ${error.stack}`, 'error');
                return false;
            }
        }
        
        async function testFaceModel() {
            const success = await testModel('äººè„¸æ£€æµ‹', '/models/face_detection_model/model.json');
            
            if (success) {
                showNotification('äººè„¸æ£€æµ‹æ¨¡å‹æµ‹è¯•é€šè¿‡ï¼', 'success');
            } else {
                showNotification('äººè„¸æ£€æµ‹æ¨¡å‹æµ‹è¯•å¤±è´¥', 'error');
            }
        }
        
        async function testPlateModel() {
            const success = await testModel('é¤ç›˜æ£€æµ‹', '/models/plate_detection_model/model.json');
            
            if (success) {
                showNotification('é¤ç›˜æ£€æµ‹æ¨¡å‹æµ‹è¯•é€šè¿‡ï¼', 'success');
            } else {
                showNotification('é¤ç›˜æ£€æµ‹æ¨¡å‹æµ‹è¯•å¤±è´¥', 'error');
            }
        }
        
        async function testBothModels() {
            log('å¼€å§‹æ‰¹é‡æµ‹è¯•æ‰€æœ‰æ¨¡å‹...', 'info');
            
            const faceResult = await testModel('äººè„¸æ£€æµ‹', '/models/face_detection_model/model.json');
            const plateResult = await testModel('é¤ç›˜æ£€æµ‹', '/models/plate_detection_model/model.json');
            
            const successCount = [faceResult, plateResult].filter(Boolean).length;
            
            log(`\\nğŸ“Š æµ‹è¯•æ€»ç»“:`, 'info');
            log(`âœ… æˆåŠŸ: ${successCount}/2 ä¸ªæ¨¡å‹`);
            log(`âŒ å¤±è´¥: ${2 - successCount}/2 ä¸ªæ¨¡å‹`);
            
            if (successCount === 2) {
                showNotification('æ‰€æœ‰æ¨¡å‹æµ‹è¯•é€šè¿‡ï¼ğŸ‰', 'success');
            } else {
                showNotification(`${successCount}/2 ä¸ªæ¨¡å‹æµ‹è¯•é€šè¿‡`, 'error');
            }
        }
        
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `test-section ${type}`;
            notification.innerHTML = `<h4>${message}</h4>`;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            loadSystemInfo();
            log('æ¨¡å‹æµ‹è¯•å·¥å…·å·²å°±ç»ª');
            log('è¯·ç¡®ä¿å·²å¯åŠ¨æœ¬åœ°WebæœåŠ¡å™¨ï¼Œæ¨¡å‹æ–‡ä»¶å¯æ­£å¸¸è®¿é—®');
        });
        
        // ç›‘å¬TensorFlow.jsé”™è¯¯
        window.addEventListener('error', (event) => {
            log('JavaScripté”™è¯¯: ' + event.error.message, 'error');
        });
    </script>
</body>
</html>