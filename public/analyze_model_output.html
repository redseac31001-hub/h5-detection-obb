<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>YOLOæ¨¡å‹è¾“å‡ºåˆ†æ</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0/dist/tf-backend-webgl.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .container { background: white; padding: 20px; border-radius: 8px; margin: 10px 0; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; font-weight: bold; }
        .loading { background: #e3f2fd; color: #1976d2; }
        .success { background: #e8f5e8; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
        pre { background: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto; }
        .data-sample { max-height: 300px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>YOLOæ¨¡å‹è¾“å‡ºæ·±åº¦åˆ†æ</h1>
    <div id="status" class="status loading">æ­£åœ¨åˆå§‹åŒ–...</div>
    <div id="results"></div>

    <script>
        async function analyzeModel() {
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');
            
            try {
                statusDiv.innerHTML = 'ğŸ”„ æ­£åœ¨åŠ è½½æ¨¡å‹...';
                await tf.ready();
                
                const model = await tf.loadGraphModel('/public/models/yolodetection/model.json');
                
                statusDiv.innerHTML = 'ğŸ” æ­£åœ¨åˆ†ææ¨¡å‹ç»“æ„...';
                
                // è¯¦ç»†åˆ†ææ¨¡å‹
                const modelInfo = {
                    inputs: model.inputs.map(input => ({
                        name: input.name,
                        shape: input.shape,
                        dtype: input.dtype
                    })),
                    outputs: model.outputs.map(output => ({
                        name: output.name,
                        shape: output.shape,
                        dtype: output.dtype
                    })),
                    inputNodes: model.inputNodes.map(node => node.name || 'unnamed'),
                    outputNodes: model.outputNodes.map(node => node.name || 'unnamed')
                };
                
                resultsDiv.innerHTML += `
                    <div class="container">
                        <h3>ğŸ“‹ æ¨¡å‹ç»“æ„ä¿¡æ¯</h3>
                        <pre>${JSON.stringify(modelInfo, null, 2)}</pre>
                    </div>
                `;
                
                // è¿›è¡Œæ¨ç†å¹¶åˆ†æè¾“å‡º
                statusDiv.innerHTML = 'ğŸ§ª æ­£åœ¨è¿›è¡Œæ¨ç†åˆ†æ...';
                
                const testInput = tf.randomNormal([1, 640, 640, 3]);
                const predictions = model.predict(testInput);
                
                let outputAnalysis = {};
                
                if (Array.isArray(predictions)) {
                    outputAnalysis.type = 'Array';
                    outputAnalysis.length = predictions.length;
                    outputAnalysis.outputs = [];
                    
                    for (let i = 0; i < predictions.length; i++) {
                        const output = predictions[i];
                        const data = await output.data();
                        
                        outputAnalysis.outputs.push({
                            index: i,
                            shape: output.shape,
                            dtype: output.dtype,
                            dataLength: data.length,
                            sampleData: Array.from(data.slice(0, 50)),
                            statistics: {
                                min: Math.min(...data),
                                max: Math.max(...data),
                                mean: Array.from(data).reduce((a, b) => a + b, 0) / data.length,
                                nonZeroCount: Array.from(data).filter(x => Math.abs(x) > 1e-6).length
                            }
                        });
                    }
                } else {
                    const data = await predictions.data();
                    outputAnalysis = {
                        type: 'Tensor',
                        shape: predictions.shape,
                        dtype: predictions.dtype,
                        dataLength: data.length,
                        sampleData: Array.from(data.slice(0, 50)),
                        statistics: {
                            min: Math.min(...data),
                            max: Math.max(...data),
                            mean: Array.from(data).reduce((a, b) => a + b, 0) / data.length,
                            nonZeroCount: Array.from(data).filter(x => Math.abs(x) > 1e-6).length
                        }
                    };
                }
                
                resultsDiv.innerHTML += `
                    <div class="container">
                        <h3>ğŸ“Š è¾“å‡ºåˆ†æ</h3>
                        <div class="data-sample">
                            <pre>${JSON.stringify(outputAnalysis, null, 2)}</pre>
                        </div>
                    </div>
                `;
                
                // åˆ†æYOLOè¾“å‡ºæ ¼å¼
                statusDiv.innerHTML = 'ğŸ” æ­£åœ¨åˆ†æYOLOè¾“å‡ºæ ¼å¼...';
                
                let yoloAnalysis = analyzeYOLOFormat(outputAnalysis);
                
                resultsDiv.innerHTML += `
                    <div class="container">
                        <h3>ğŸ¯ YOLOæ ¼å¼åˆ†æ</h3>
                        <pre>${JSON.stringify(yoloAnalysis, null, 2)}</pre>
                    </div>
                `;
                
                // æ¸…ç†
                testInput.dispose();
                if (Array.isArray(predictions)) {
                    predictions.forEach(p => p.dispose());
                } else {
                    predictions.dispose();
                }
                
                statusDiv.innerHTML = 'âœ… åˆ†æå®Œæˆ';
                statusDiv.className = 'status success';
                
            } catch (error) {
                console.error('åˆ†æå¤±è´¥:', error);
                statusDiv.innerHTML = `âŒ åˆ†æå¤±è´¥: ${error.message}`;
                statusDiv.className = 'status error';
            }
        }
        
        function analyzeYOLOFormat(outputAnalysis) {
            let analysis = {
                detectedFormat: 'unknown',
                recommendations: []
            };
            
            if (outputAnalysis.type === 'Array') {
                analysis.detectedFormat = 'Multi-output model';
                analysis.recommendations.push('ä½¿ç”¨ç¬¬ä¸€ä¸ªè¾“å‡ºè¿›è¡Œæ£€æµ‹');
                
                const firstOutput = outputAnalysis.outputs[0];
                if (firstOutput && firstOutput.shape.length === 3) {
                    const [batch, features, detections] = firstOutput.shape;
                    analysis.possibleFormat = `YOLO v8/v11 format: [${batch}, ${features}, ${detections}]`;
                    analysis.recommendations.push(`å¯èƒ½æœ‰ ${detections} ä¸ªå€™é€‰æ£€æµ‹æ¡†`);
                    analysis.recommendations.push(`æ¯ä¸ªæ£€æµ‹æœ‰ ${features} ä¸ªç‰¹å¾ (4ä¸ªbbox + ${features-4}ä¸ªç±»åˆ«)`);
                }
            } else {
                const shape = outputAnalysis.shape;
                if (shape.length === 3) {
                    const [batch, features, detections] = shape;
                    analysis.detectedFormat = 'YOLO v8/v11 format';
                    analysis.possibleFormat = `[${batch}, ${features}, ${detections}]`;
                    analysis.recommendations.push(`æœ‰ ${detections} ä¸ªå€™é€‰æ£€æµ‹æ¡†`);
                    analysis.recommendations.push(`æ¯ä¸ªæ£€æµ‹æœ‰ ${features} ä¸ªç‰¹å¾`);
                    
                    if (features === 12) {
                        analysis.recommendations.push('å¯èƒ½æ˜¯ 4(bbox) + 1(objectness) + 7(classes) æ ¼å¼');
                    } else if (features === 11) {
                        analysis.recommendations.push('å¯èƒ½æ˜¯ 4(bbox) + 7(classes) æ ¼å¼');
                    }
                } else if (shape.length === 2) {
                    analysis.detectedFormat = 'Flattened format';
                    analysis.recommendations.push('éœ€è¦reshapeä¸ºæ­£ç¡®çš„YOLOæ ¼å¼');
                }
            }
            
            return analysis;
        }
        
        window.addEventListener('load', analyzeModel);
    </script>
</body>
</html>