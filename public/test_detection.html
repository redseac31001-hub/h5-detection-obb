<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO æ¨¡å‹å›¾ç‰‡æ£€æµ‹æµ‹è¯•</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0/dist/tf-backend-webgl.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .loading { background: #e3f2fd; color: #1976d2; }
        .success { background: #e8f5e8; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
        .image-container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
        }
        .test-image {
            max-width: 100%;
            border: 2px solid #ddd;
            border-radius: 4px;
        }
        .detection-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            border: 2px solid #4caf50;
            border-radius: 4px;
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .detection-item {
            background: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid #4caf50;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #2196f3;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #1976d2;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ½ï¸ YOLO é¤å…·æ£€æµ‹æ¨¡å‹æµ‹è¯•</h1>
        
        <div id="status" class="status loading">æ­£åœ¨åˆå§‹åŒ–...</div>
        
        <div class="controls">
            <button id="startBtn" onclick="startDetection()" disabled>å¼€å§‹æ£€æµ‹</button>
            <button onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
        </div>
        
        <div class="image-container">
            <img id="testImage" class="test-image" src="/test/111532922-src.jpg" 
                 onload="onImageLoaded()" onerror="onImageError()">
            <canvas id="detectionCanvas" class="detection-canvas"></canvas>
        </div>
        
        <div id="results" class="results" style="display: none;">
            <h3>æ£€æµ‹ç»“æœï¼š</h3>
            <div id="detectionsList"></div>
            <div id="statistics"></div>
        </div>
    </div>

    <script>
        let model = null;
        let isModelLoaded = false;
        let testImageLoaded = false;
        
        const classNames = [
            'Fruit_Bowl',
            'Large_Dish_for_Vegetables', 
            'Large_Noodle_Bowl',
            'Oval_Plate_for_Staple_Food',
            'Small_Dish_for_Vegetables',
            'Small_Noodle_Bowl',
            'Yogurt_Container'
        ];
        
        const priceMapping = {
            'Fruit_Bowl': 15.0,
            'Large_Dish_for_Vegetables': 18.0,
            'Large_Noodle_Bowl': 22.0,
            'Oval_Plate_for_Staple_Food': 25.0,
            'Small_Dish_for_Vegetables': 12.0,
            'Small_Noodle_Bowl': 18.0,
            'Yogurt_Container': 8.0
        };

        async function initializeModel() {
            const statusDiv = document.getElementById('status');
            
            try {
                statusDiv.innerHTML = 'ğŸ”„ æ­£åœ¨åˆå§‹åŒ– TensorFlow.js...';
                await tf.ready();
                console.log('TensorFlow.js åç«¯:', tf.getBackend());
                
                statusDiv.innerHTML = 'ğŸ“¥ æ­£åœ¨åŠ è½½ YOLO æ¨¡å‹...';
                model = await tf.loadGraphModel('/models/yolodetection/model.json');
                
                console.log('âœ… æ¨¡å‹åŠ è½½æˆåŠŸ');
                console.log('è¾“å…¥å½¢çŠ¶:', model.inputs.map(input => input.shape));
                console.log('è¾“å‡ºå½¢çŠ¶:', model.outputs.map(output => output.shape));
                
                // é¢„çƒ­æ¨¡å‹
                statusDiv.innerHTML = 'ğŸ”¥ æ­£åœ¨é¢„çƒ­æ¨¡å‹...';
                const warmupInput = tf.randomNormal([1, 640, 640, 3]);
                const warmupOutput = model.predict(warmupInput);
                warmupInput.dispose();
                warmupOutput.dispose();
                
                isModelLoaded = true;
                statusDiv.innerHTML = 'âœ… æ¨¡å‹åŠ è½½å®Œæˆï¼Œå‡†å¤‡æ£€æµ‹ï¼';
                statusDiv.className = 'status success';
                
                updateStartButton();
                
            } catch (error) {
                console.error('âŒ æ¨¡å‹åŠ è½½å¤±è´¥:', error);
                statusDiv.innerHTML = 'âŒ æ¨¡å‹åŠ è½½å¤±è´¥: ' + error.message;
                statusDiv.className = 'status error';
            }
        }
        
        function onImageLoaded() {
            console.log('âœ… æµ‹è¯•å›¾ç‰‡åŠ è½½æˆåŠŸ');
            testImageLoaded = true;
            updateStartButton();
        }
        
        function onImageError() {
            console.error('âŒ æµ‹è¯•å›¾ç‰‡åŠ è½½å¤±è´¥');
            document.getElementById('status').innerHTML = 'âŒ æµ‹è¯•å›¾ç‰‡åŠ è½½å¤±è´¥';
            document.getElementById('status').className = 'status error';
        }
        
        function updateStartButton() {
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = !(isModelLoaded && testImageLoaded);
        }

        async function startDetection() {
            if (!model || !isModelLoaded) {
                alert('æ¨¡å‹å°šæœªåŠ è½½å®Œæˆ');
                return;
            }
            
            const statusDiv = document.getElementById('status');
            const startBtn = document.getElementById('startBtn');
            
            try {
                startBtn.disabled = true;
                statusDiv.innerHTML = 'ğŸ” æ­£åœ¨è¿›è¡Œæ£€æµ‹...';
                statusDiv.className = 'status loading';
                
                const detections = await detectObjects();
                displayResults(detections);
                
                statusDiv.innerHTML = `âœ… æ£€æµ‹å®Œæˆï¼å‘ç° ${detections.length} ä¸ªç‰©ä½“`;
                statusDiv.className = 'status success';
                
            } catch (error) {
                console.error('æ£€æµ‹å¤±è´¥:', error);
                statusDiv.innerHTML = 'âŒ æ£€æµ‹å¤±è´¥: ' + error.message;
                statusDiv.className = 'status error';
            } finally {
                startBtn.disabled = false;
            }
        }

        async function detectObjects() {
            const img = document.getElementById('testImage');
            const canvas = document.getElementById('detectionCanvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // é¢„å¤„ç†å›¾ç‰‡
            const tensor = preprocessImage(img);
            
            // æ¨¡å‹æ¨ç†
            const predictions = model.predict(tensor);
            console.log('åŸå§‹é¢„æµ‹ç»“æœ:', predictions);
            
            // å¤„ç†é¢„æµ‹ç»“æœ - å¯èƒ½æ˜¯æ•°ç»„æˆ–å•ä¸ªtensor
            let outputTensor;
            if (Array.isArray(predictions)) {
                outputTensor = predictions[0]; // å–ç¬¬ä¸€ä¸ªè¾“å‡º
                console.log('ä½¿ç”¨æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ªè¾“å‡º:', outputTensor);
            } else {
                outputTensor = predictions;
                console.log('ä½¿ç”¨å•ä¸€è¾“å‡º:', outputTensor);
            }
            
            // åå¤„ç†ç»“æœ
            const detections = await postprocessPredictions(outputTensor, img.width, img.height);
            
            // ç»˜åˆ¶æ£€æµ‹æ¡†
            drawDetections(ctx, detections);
            
            // æ¸…ç†å†…å­˜
            tensor.dispose();
            if (Array.isArray(predictions)) {
                predictions.forEach(p => p.dispose());
            } else {
                predictions.dispose();
            }
            
            return detections;
        }
        
        function preprocessImage(img) {
            // å°†å›¾ç‰‡è½¬æ¢ä¸ºtensor
            let tensor = tf.browser.fromPixels(img);
            
            // è°ƒæ•´å°ºå¯¸åˆ°640x640
            tensor = tf.image.resizeBilinear(tensor, [640, 640]);
            
            // å½’ä¸€åŒ–åˆ°0-1
            tensor = tensor.div(255.0);
            
            // æ·»åŠ batchç»´åº¦
            tensor = tensor.expandDims(0);
            
            return tensor;
        }
        
        async function postprocessPredictions(predictions, imgWidth, imgHeight) {
            const data = await predictions.data();
            const shape = predictions.shape;
            console.log('é¢„æµ‹è¾“å‡ºå½¢çŠ¶:', shape);
            console.log('è¾“å‡ºæ•°æ®ç¤ºä¾‹:', Array.from(data.slice(0, 20)));
            
            const detections = [];
            
            // æ ¹æ®metadata.yamlï¼Œè¿™æ˜¯YOLO11næ¨¡å‹ï¼Œè¾“å‡ºæ ¼å¼ä¸º [1, features, 8400]
            // features = 4(bbox) + 7(classes) = 11ï¼Œæ²¡æœ‰objectnessåˆ†æ•°
            if (shape.length === 3 && shape[0] === 1) {
                const numClasses = 7; // æˆ‘ä»¬æœ‰7ä¸ªé¤å…·ç±»åˆ«
                const numFeatures = shape[1]; // 11 = 4(bbox) + 7(classes)
                const numDetections = shape[2]; // é€šå¸¸æ˜¯8400
                
                console.log(`YOLO11næ ¼å¼: [${shape[0]}, ${numFeatures}, ${numDetections}]`);
                console.log(`å¤„ç† ${numDetections} ä¸ªæ£€æµ‹ï¼Œæ¯ä¸ªæœ‰ ${numFeatures} ä¸ªç‰¹å¾`);
                
                // YOLO v11 è¾“å‡ºæ ¼å¼: [batch, features, detections]
                // features æ’åˆ—: [x_center, y_center, width, height, class0, class1, ..., class6]
                
                for (let i = 0; i < numDetections; i++) {
                    // è·å–è¾¹ç•Œæ¡†åæ ‡ (å‰4ä¸ªç‰¹å¾)
                    const xCenter = data[i]; // ç¬¬iä¸ªæ£€æµ‹çš„xä¸­å¿ƒ (å½’ä¸€åŒ–åæ ‡ 0-1)
                    const yCenter = data[numDetections + i]; // yä¸­å¿ƒ
                    const width = data[2 * numDetections + i]; // å®½åº¦ 
                    const height = data[3 * numDetections + i]; // é«˜åº¦
                    
                    // æŸ¥æ‰¾æœ€é«˜ç½®ä¿¡åº¦çš„ç±»åˆ« (ç‰¹å¾4-10)
                    let maxClassScore = 0;
                    let maxClassIndex = 0;
                    
                    for (let classIdx = 0; classIdx < numClasses; classIdx++) {
                        const featureIdx = 4 + classIdx; // ç±»åˆ«åˆ†æ•°ä»ç¬¬4ä¸ªç‰¹å¾å¼€å§‹
                        const classScore = data[featureIdx * numDetections + i];
                        if (classScore > maxClassScore) {
                            maxClassScore = classScore;
                            maxClassIndex = classIdx;
                        }
                    }
                    
                    // è®¾ç½®æ›´é«˜çš„ç½®ä¿¡åº¦é˜ˆå€¼ï¼Œå› ä¸ºæ²¡æœ‰objectnessåˆ†æ•°
                    if (maxClassScore > 0.6) {  
                        // å°†å½’ä¸€åŒ–åæ ‡(0-1)è½¬æ¢ä¸ºåƒç´ åæ ‡
                        const centerX = xCenter * imgWidth;
                        const centerY = yCenter * imgHeight;
                        const boxWidth = width * imgWidth;
                        const boxHeight = height * imgHeight;
                        
                        // è½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡
                        const x = Math.max(0, centerX - boxWidth / 2);
                        const y = Math.max(0, centerY - boxHeight / 2);
                        const w = Math.min(imgWidth - x, boxWidth);
                        const h = Math.min(imgHeight - y, boxHeight);
                        
                        // è¿‡æ»¤æ‰å¤ªå°æˆ–æ— æ•ˆçš„æ¡†
                        if (w > 10 && h > 10 && x + w <= imgWidth && y + h <= imgHeight) {
                            detections.push({
                                class: classNames[maxClassIndex] || `class_${maxClassIndex}`,
                                confidence: maxClassScore,
                                bbox: { x, y, width: w, height: h }
                            });
                            
                            console.log(`æœ‰æ•ˆæ£€æµ‹: ${classNames[maxClassIndex]}, ç½®ä¿¡åº¦: ${maxClassScore.toFixed(3)}, ä½ç½®: (${Math.round(x)}, ${Math.round(y)}, ${Math.round(w)}, ${Math.round(h)})`);
                        }
                    }
                }
            } else {
                console.warn('æœªçŸ¥çš„è¾“å‡ºå½¢çŠ¶:', shape);
                // å°è¯•è€æ ¼å¼è§£æ
                const numDetections = shape[1] || shape[0];
                const numFeatures = shape[2] || shape[1];
                
                for (let i = 0; i < Math.min(numDetections, 1000); i++) {
                    const baseIndex = i * numFeatures;
                    const confidence = data[baseIndex + 4] || data[baseIndex + 0];
                    
                    if (confidence > 0.6) {
                        const xCenter = data[baseIndex + 0];
                        const yCenter = data[baseIndex + 1];
                        const width = data[baseIndex + 2];
                        const height = data[baseIndex + 3];
                        
                        detections.push({
                            class: 'detected_object',
                            confidence: confidence,
                            bbox: { 
                                x: (xCenter - width / 2) * imgWidth,
                                y: (yCenter - height / 2) * imgHeight,
                                width: width * imgWidth,
                                height: height * imgHeight
                            }
                        });
                    }
                }
            }
            
            console.log(`æ‰¾åˆ° ${detections.length} ä¸ªæœ‰æ•ˆæ£€æµ‹`);
            
            // åº”ç”¨NMS (éæå¤§å€¼æŠ‘åˆ¶) å»é™¤é‡å¤æ£€æµ‹
            const nmsDetections = applyNMS(detections, 0.45); // IoUé˜ˆå€¼0.45
            console.log(`NMSåå‰©ä½™ ${nmsDetections.length} ä¸ªæ£€æµ‹`);
            
            return nmsDetections;
        }
        
        function drawDetections(ctx, detections) {
            detections.forEach((detection, index) => {
                const { bbox, class: className, confidence } = detection;
                
                // ç»˜åˆ¶è¾¹ç•Œæ¡†
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 3;
                ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
                
                // ç»˜åˆ¶æ ‡ç­¾èƒŒæ™¯
                const label = `${className} (${(confidence * 100).toFixed(1)}%)`;
                ctx.font = '16px Arial';
                const textWidth = ctx.measureText(label).width;
                
                ctx.fillStyle = '#4caf50';
                ctx.fillRect(bbox.x, bbox.y - 25, textWidth + 10, 25);
                
                // ç»˜åˆ¶æ ‡ç­¾æ–‡å­—
                ctx.fillStyle = 'white';
                ctx.fillText(label, bbox.x + 5, bbox.y - 5);
            });
        }
        
        function displayResults(detections) {
            const resultsDiv = document.getElementById('results');
            const listDiv = document.getElementById('detectionsList');
            const statsDiv = document.getElementById('statistics');
            
            resultsDiv.style.display = 'block';
            
            // æ˜¾ç¤ºæ£€æµ‹åˆ—è¡¨
            listDiv.innerHTML = '';
            let totalPrice = 0;
            
            detections.forEach((detection, index) => {
                const price = priceMapping[detection.class] || 0;
                totalPrice += price;
                
                const item = document.createElement('div');
                item.className = 'detection-item';
                item.innerHTML = `
                    <strong>${detection.class}</strong> - 
                    ç½®ä¿¡åº¦: ${(detection.confidence * 100).toFixed(1)}% - 
                    ä»·æ ¼: Â¥${price.toFixed(2)} - 
                    ä½ç½®: (${Math.round(detection.bbox.x)}, ${Math.round(detection.bbox.y)}) 
                    å°ºå¯¸: ${Math.round(detection.bbox.width)}Ã—${Math.round(detection.bbox.height)}
                `;
                listDiv.appendChild(item);
            });
            
            // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
            const categoryCount = {};
            detections.forEach(d => {
                categoryCount[d.class] = (categoryCount[d.class] || 0) + 1;
            });
            
            statsDiv.innerHTML = `
                <h4>ç»Ÿè®¡ä¿¡æ¯ï¼š</h4>
                <p><strong>æ€»æ£€æµ‹æ•°é‡ï¼š</strong> ${detections.length}</p>
                <p><strong>æ€»ä»·æ ¼ï¼š</strong> Â¥${totalPrice.toFixed(2)}</p>
                <p><strong>ç±»åˆ«åˆ†å¸ƒï¼š</strong> ${Object.entries(categoryCount).map(([k, v]) => `${k}: ${v}`).join(', ')}</p>
            `;
        }
        
        // éæå¤§å€¼æŠ‘åˆ¶å‡½æ•°
        function applyNMS(detections, iouThreshold = 0.45) {
            if (detections.length === 0) return detections;
            
            // æŒ‰ç½®ä¿¡åº¦æ’åº
            const sortedDetections = detections.sort((a, b) => b.confidence - a.confidence);
            const selectedDetections = [];
            
            for (let i = 0; i < sortedDetections.length; i++) {
                const currentDetection = sortedDetections[i];
                let shouldKeep = true;
                
                // æ£€æŸ¥ä¸å·²é€‰æ‹©çš„æ£€æµ‹æ˜¯å¦é‡å è¿‡å¤š
                for (let j = 0; j < selectedDetections.length; j++) {
                    const selectedDetection = selectedDetections[j];
                    
                    // åªå¯¹åŒç±»åˆ«çš„æ£€æµ‹è¿›è¡ŒNMS
                    if (currentDetection.class === selectedDetection.class) {
                        const iou = calculateIoU(currentDetection.bbox, selectedDetection.bbox);
                        if (iou > iouThreshold) {
                            shouldKeep = false;
                            break;
                        }
                    }
                }
                
                if (shouldKeep) {
                    selectedDetections.push(currentDetection);
                }
            }
            
            return selectedDetections;
        }
        
        // è®¡ç®—ä¸¤ä¸ªè¾¹ç•Œæ¡†çš„IoU
        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
            
            if (x2 <= x1 || y2 <= y1) {
                return 0;
            }
            
            const intersection = (x2 - x1) * (y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;
            
            return intersection / union;
        }
        
        function clearResults() {
            document.getElementById('results').style.display = 'none';
            const canvas = document.getElementById('detectionCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // é¡µé¢åŠ è½½ååˆå§‹åŒ–
        window.addEventListener('load', initializeModel);
    </script>
</body>
</html>