<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>YOLO11næ•°æ®æ ¼å¼è°ƒè¯•å™¨</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0/dist/tf-backend-webgl.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .container { background: white; padding: 20px; border-radius: 8px; margin: 10px 0; border: 1px solid #ddd; }
        pre { background: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto; max-height: 400px; }
        .analysis { background: #e3f2fd; padding: 15px; border-radius: 4px; margin: 10px 0; }
        .highlight { background: yellow; font-weight: bold; }
        .success { background: #e8f5e8; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
    </style>
</head>
<body>
    <h1>ğŸ” YOLO11næ•°æ®æ ¼å¼æ·±åº¦è°ƒè¯•</h1>
    <div id="output"></div>

    <script>
        async function analyzeYOLOFormat() {
            const output = document.getElementById('output');
            
            try {
                output.innerHTML += '<div class="container"><h3>ğŸ”„ æ­£åœ¨åŠ è½½æ¨¡å‹...</h3></div>';
                
                await tf.ready();
                const model = await tf.loadGraphModel('/models/yolodetection/model.json');
                
                output.innerHTML += '<div class="container success"><h3>âœ… æ¨¡å‹åŠ è½½æˆåŠŸ</h3></div>';
                
                // åˆ›å»ºæµ‹è¯•è¾“å…¥
                const testInput = tf.randomNormal([1, 640, 640, 3]);
                const predictions = model.predict(testInput);
                
                let outputTensor;
                if (Array.isArray(predictions)) {
                    outputTensor = predictions[0];
                } else {
                    outputTensor = predictions;
                }
                
                const data = await outputTensor.data();
                const shape = outputTensor.shape;
                
                output.innerHTML += `
                    <div class="container">
                        <h3>ğŸ“Š è¾“å‡ºä¿¡æ¯</h3>
                        <p><strong>å½¢çŠ¶:</strong> [${shape.join(', ')}]</p>
                        <p><strong>æ€»æ•°æ®é‡:</strong> ${data.length}</p>
                        <p><strong>æ•°æ®ç±»å‹:</strong> ${outputTensor.dtype}</p>
                    </div>
                `;
                
                // åˆ†ææ•°æ®åˆ†å¸ƒ
                const stats = analyzeDataDistribution(data);
                output.innerHTML += `
                    <div class="container">
                        <h3>ğŸ“ˆ æ•°æ®ç»Ÿè®¡</h3>
                        <pre>${JSON.stringify(stats, null, 2)}</pre>
                    </div>
                `;
                
                // åˆ†æå¯èƒ½çš„æ ¼å¼
                const formatAnalysis = analyzeFormat(shape, data);
                output.innerHTML += `
                    <div class="container analysis">
                        <h3>ğŸ¯ æ ¼å¼åˆ†æ</h3>
                        ${formatAnalysis}
                    </div>
                `;
                
                // å°è¯•ä¸åŒçš„è§£ææ–¹æ³•
                const parseResults = tryDifferentParseMethods(shape, data);
                output.innerHTML += `
                    <div class="container">
                        <h3>ğŸ§ª è§£ææ–¹æ³•æµ‹è¯•</h3>
                        ${parseResults}
                    </div>
                `;
                
                // æ¸…ç†
                testInput.dispose();
                if (Array.isArray(predictions)) {
                    predictions.forEach(p => p.dispose());
                } else {
                    predictions.dispose();
                }
                
            } catch (error) {
                output.innerHTML += `<div class="container error"><h3>âŒ é”™è¯¯: ${error.message}</h3></div>`;
            }
        }
        
        function analyzeDataDistribution(data) {
            const values = Array.from(data);
            
            return {
                min: Math.min(...values),
                max: Math.max(...values),
                mean: values.reduce((a, b) => a + b, 0) / values.length,
                nonZeroCount: values.filter(x => Math.abs(x) > 1e-6).length,
                positiveCount: values.filter(x => x > 0).length,
                zeroCount: values.filter(x => Math.abs(x) < 1e-6).length,
                ranges: {
                    between_0_1: values.filter(x => x >= 0 && x <= 1).length,
                    between_1_10: values.filter(x => x > 1 && x <= 10).length,
                    greater_than_10: values.filter(x => x > 10).length,
                    negative: values.filter(x => x < 0).length
                }
            };
        }
        
        function analyzeFormat(shape, data) {
            let analysis = '';
            
            if (shape.length === 3 && shape[0] === 1) {
                const [batch, features, detections] = shape;
                
                analysis += `<p><strong>æ£€æµ‹åˆ°3Då¼ é‡æ ¼å¼:</strong> [${batch}, ${features}, ${detections}]</p>`;
                analysis += `<p>å¯èƒ½çš„è§£é‡Š:</p>`;
                analysis += `<ul>`;
                analysis += `<li>æ‰¹æ¬¡å¤§å°: ${batch}</li>`;
                analysis += `<li>æ¯ä¸ªæ£€æµ‹çš„ç‰¹å¾æ•°: ${features}</li>`;
                analysis += `<li>å€™é€‰æ£€æµ‹æ•°é‡: ${detections}</li>`;
                analysis += `</ul>`;
                
                if (features === 11) {
                    analysis += `<p class="highlight">ç‰¹å¾æ•°11å¯èƒ½å¯¹åº”: 4(bbox) + 7(classes)</p>`;
                } else if (features === 12) {
                    analysis += `<p class="highlight">ç‰¹å¾æ•°12å¯èƒ½å¯¹åº”: 4(bbox) + 1(objectness) + 7(classes)</p>`;
                }
                
                // åˆ†ææ•°æ®æ’åˆ—
                analysis += `<h4>æ•°æ®æ’åˆ—åˆ†æ:</h4>`;
                analysis += `<p><strong>æ–¹å¼1 (æŒ‰æ£€æµ‹æ’åˆ—):</strong> [det0_feat0, det0_feat1, ..., det1_feat0, det1_feat1, ...]</p>`;
                analysis += `<p><strong>æ–¹å¼2 (æŒ‰ç‰¹å¾æ’åˆ—):</strong> [æ‰€æœ‰feat0, æ‰€æœ‰feat1, ...]</p>`;
                
                // æ£€æŸ¥å“ªç§æ’åˆ—æ›´å¯èƒ½
                const sample1 = Array.from(data.slice(0, features * 5)); // å‰5ä¸ªæ£€æµ‹çš„æ‰€æœ‰ç‰¹å¾
                const sample2 = Array.from(data.slice(0, detections)).concat(Array.from(data.slice(detections, detections * 2))); // å‰ä¸¤ä¸ªç‰¹å¾çš„æ‰€æœ‰æ£€æµ‹
                
                analysis += `<p><strong>å‰5ä¸ªæ£€æµ‹æ•°æ®æ ·æœ¬ (æ–¹å¼1):</strong></p>`;
                analysis += `<pre>${JSON.stringify(sample1, null, 2)}</pre>`;
                
                analysis += `<p><strong>å‰ä¸¤ä¸ªç‰¹å¾æ•°æ®æ ·æœ¬ (æ–¹å¼2):</strong></p>`;
                analysis += `<pre>${JSON.stringify(sample2.slice(0, 20), null, 2)}</pre>`;
            }
            
            return analysis;
        }
        
        function tryDifferentParseMethods(shape, data) {
            const [batch, features, detections] = shape;
            let results = '';
            
            // æ–¹æ³•1: æŒ‰ç‰¹å¾æ’åˆ— (æ¨è)
            results += `<h4>æ–¹æ³•1: æŒ‰ç‰¹å¾æ’åˆ—è§£æ</h4>`;
            try {
                const method1Results = parseMethod1(data, features, detections);
                results += `<p>âœ… æˆåŠŸè§£æï¼Œæ‰¾åˆ°${method1Results.validDetections}ä¸ªæœ‰æ•ˆæ£€æµ‹</p>`;
                results += `<pre>${JSON.stringify(method1Results.samples, null, 2)}</pre>`;
            } catch (e) {
                results += `<p>âŒ è§£æå¤±è´¥: ${e.message}</p>`;
            }
            
            // æ–¹æ³•2: æŒ‰æ£€æµ‹æ’åˆ—
            results += `<h4>æ–¹æ³•2: æŒ‰æ£€æµ‹æ’åˆ—è§£æ</h4>`;
            try {
                const method2Results = parseMethod2(data, features, detections);
                results += `<p>âœ… æˆåŠŸè§£æï¼Œæ‰¾åˆ°${method2Results.validDetections}ä¸ªæœ‰æ•ˆæ£€æµ‹</p>`;
                results += `<pre>${JSON.stringify(method2Results.samples, null, 2)}</pre>`;
            } catch (e) {
                results += `<p>âŒ è§£æå¤±è´¥: ${e.message}</p>`;
            }
            
            return results;
        }
        
        function parseMethod1(data, features, detections) {
            // æŒ‰ç‰¹å¾æ’åˆ—: [æ‰€æœ‰x, æ‰€æœ‰y, æ‰€æœ‰w, æ‰€æœ‰h, æ‰€æœ‰class0, ...]
            const validDetections = [];
            
            for (let i = 0; i < Math.min(detections, 100); i++) { // åªæ£€æŸ¥å‰100ä¸ª
                const x = data[0 * detections + i];
                const y = data[1 * detections + i];
                const w = data[2 * detections + i];
                const h = data[3 * detections + i];
                
                // æ£€æŸ¥åæ ‡åˆç†æ€§
                if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && w > 0 && w <= 1 && h > 0 && h <= 1) {
                    let maxScore = 0;
                    let maxClass = 0;
                    
                    for (let c = 0; c < 7; c++) {
                        const score = data[(4 + c) * detections + i];
                        if (score > maxScore) {
                            maxScore = score;
                            maxClass = c;
                        }
                    }
                    
                    if (maxScore > 0.01) {
                        validDetections.push({
                            index: i,
                            bbox: { x, y, w, h },
                            class: maxClass,
                            confidence: maxScore
                        });
                    }
                }
            }
            
            return {
                validDetections: validDetections.length,
                samples: validDetections.slice(0, 5)
            };
        }
        
        function parseMethod2(data, features, detections) {
            // æŒ‰æ£€æµ‹æ’åˆ—: [det0çš„æ‰€æœ‰ç‰¹å¾, det1çš„æ‰€æœ‰ç‰¹å¾, ...]
            const validDetections = [];
            
            for (let i = 0; i < Math.min(detections, 100); i++) {
                const baseIdx = i * features;
                const x = data[baseIdx + 0];
                const y = data[baseIdx + 1];
                const w = data[baseIdx + 2];
                const h = data[baseIdx + 3];
                
                if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && w > 0 && w <= 1 && h > 0 && h <= 1) {
                    let maxScore = 0;
                    let maxClass = 0;
                    
                    for (let c = 0; c < 7; c++) {
                        const score = data[baseIdx + 4 + c];
                        if (score > maxScore) {
                            maxScore = score;
                            maxClass = c;
                        }
                    }
                    
                    if (maxScore > 0.01) {
                        validDetections.push({
                            index: i,
                            bbox: { x, y, w, h },
                            class: maxClass,
                            confidence: maxScore
                        });
                    }
                }
            }
            
            return {
                validDetections: validDetections.length,
                samples: validDetections.slice(0, 5)
            };
        }
        
        window.addEventListener('load', analyzeYOLOFormat);
    </script>
</body>
</html>