<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>YOLO11n数据格式调试器</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0/dist/tf-backend-webgl.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .container { background: white; padding: 20px; border-radius: 8px; margin: 10px 0; border: 1px solid #ddd; }
        pre { background: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto; max-height: 400px; }
        .analysis { background: #e3f2fd; padding: 15px; border-radius: 4px; margin: 10px 0; }
        .highlight { background: yellow; font-weight: bold; }
        .success { background: #e8f5e8; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
    </style>
</head>
<body>
    <h1>🔍 YOLO11n数据格式深度调试</h1>
    <div id="output"></div>

    <script>
        async function analyzeYOLOFormat() {
            const output = document.getElementById('output');
            
            try {
                output.innerHTML += '<div class="container"><h3>🔄 正在加载模型...</h3></div>';
                
                await tf.ready();
                const model = await tf.loadGraphModel('/models/yolodetection/model.json');
                
                output.innerHTML += '<div class="container success"><h3>✅ 模型加载成功</h3></div>';
                
                // 创建测试输入
                const testInput = tf.randomNormal([1, 640, 640, 3]);
                const predictions = model.predict(testInput);
                
                let outputTensor;
                if (Array.isArray(predictions)) {
                    outputTensor = predictions[0];
                } else {
                    outputTensor = predictions;
                }
                
                const data = await outputTensor.data();
                const shape = outputTensor.shape;
                
                output.innerHTML += `
                    <div class="container">
                        <h3>📊 输出信息</h3>
                        <p><strong>形状:</strong> [${shape.join(', ')}]</p>
                        <p><strong>总数据量:</strong> ${data.length}</p>
                        <p><strong>数据类型:</strong> ${outputTensor.dtype}</p>
                    </div>
                `;
                
                // 分析数据分布
                const stats = analyzeDataDistribution(data);
                output.innerHTML += `
                    <div class="container">
                        <h3>📈 数据统计</h3>
                        <pre>${JSON.stringify(stats, null, 2)}</pre>
                    </div>
                `;
                
                // 分析可能的格式
                const formatAnalysis = analyzeFormat(shape, data);
                output.innerHTML += `
                    <div class="container analysis">
                        <h3>🎯 格式分析</h3>
                        ${formatAnalysis}
                    </div>
                `;
                
                // 尝试不同的解析方法
                const parseResults = tryDifferentParseMethods(shape, data);
                output.innerHTML += `
                    <div class="container">
                        <h3>🧪 解析方法测试</h3>
                        ${parseResults}
                    </div>
                `;
                
                // 清理
                testInput.dispose();
                if (Array.isArray(predictions)) {
                    predictions.forEach(p => p.dispose());
                } else {
                    predictions.dispose();
                }
                
            } catch (error) {
                output.innerHTML += `<div class="container error"><h3>❌ 错误: ${error.message}</h3></div>`;
            }
        }
        
        function analyzeDataDistribution(data) {
            const values = Array.from(data);
            
            return {
                min: Math.min(...values),
                max: Math.max(...values),
                mean: values.reduce((a, b) => a + b, 0) / values.length,
                nonZeroCount: values.filter(x => Math.abs(x) > 1e-6).length,
                positiveCount: values.filter(x => x > 0).length,
                zeroCount: values.filter(x => Math.abs(x) < 1e-6).length,
                ranges: {
                    between_0_1: values.filter(x => x >= 0 && x <= 1).length,
                    between_1_10: values.filter(x => x > 1 && x <= 10).length,
                    greater_than_10: values.filter(x => x > 10).length,
                    negative: values.filter(x => x < 0).length
                }
            };
        }
        
        function analyzeFormat(shape, data) {
            let analysis = '';
            
            if (shape.length === 3 && shape[0] === 1) {
                const [batch, features, detections] = shape;
                
                analysis += `<p><strong>检测到3D张量格式:</strong> [${batch}, ${features}, ${detections}]</p>`;
                analysis += `<p>可能的解释:</p>`;
                analysis += `<ul>`;
                analysis += `<li>批次大小: ${batch}</li>`;
                analysis += `<li>每个检测的特征数: ${features}</li>`;
                analysis += `<li>候选检测数量: ${detections}</li>`;
                analysis += `</ul>`;
                
                if (features === 11) {
                    analysis += `<p class="highlight">特征数11可能对应: 4(bbox) + 7(classes)</p>`;
                } else if (features === 12) {
                    analysis += `<p class="highlight">特征数12可能对应: 4(bbox) + 1(objectness) + 7(classes)</p>`;
                }
                
                // 分析数据排列
                analysis += `<h4>数据排列分析:</h4>`;
                analysis += `<p><strong>方式1 (按检测排列):</strong> [det0_feat0, det0_feat1, ..., det1_feat0, det1_feat1, ...]</p>`;
                analysis += `<p><strong>方式2 (按特征排列):</strong> [所有feat0, 所有feat1, ...]</p>`;
                
                // 检查哪种排列更可能
                const sample1 = Array.from(data.slice(0, features * 5)); // 前5个检测的所有特征
                const sample2 = Array.from(data.slice(0, detections)).concat(Array.from(data.slice(detections, detections * 2))); // 前两个特征的所有检测
                
                analysis += `<p><strong>前5个检测数据样本 (方式1):</strong></p>`;
                analysis += `<pre>${JSON.stringify(sample1, null, 2)}</pre>`;
                
                analysis += `<p><strong>前两个特征数据样本 (方式2):</strong></p>`;
                analysis += `<pre>${JSON.stringify(sample2.slice(0, 20), null, 2)}</pre>`;
            }
            
            return analysis;
        }
        
        function tryDifferentParseMethods(shape, data) {
            const [batch, features, detections] = shape;
            let results = '';
            
            // 方法1: 按特征排列 (推荐)
            results += `<h4>方法1: 按特征排列解析</h4>`;
            try {
                const method1Results = parseMethod1(data, features, detections);
                results += `<p>✅ 成功解析，找到${method1Results.validDetections}个有效检测</p>`;
                results += `<pre>${JSON.stringify(method1Results.samples, null, 2)}</pre>`;
            } catch (e) {
                results += `<p>❌ 解析失败: ${e.message}</p>`;
            }
            
            // 方法2: 按检测排列
            results += `<h4>方法2: 按检测排列解析</h4>`;
            try {
                const method2Results = parseMethod2(data, features, detections);
                results += `<p>✅ 成功解析，找到${method2Results.validDetections}个有效检测</p>`;
                results += `<pre>${JSON.stringify(method2Results.samples, null, 2)}</pre>`;
            } catch (e) {
                results += `<p>❌ 解析失败: ${e.message}</p>`;
            }
            
            return results;
        }
        
        function parseMethod1(data, features, detections) {
            // 按特征排列: [所有x, 所有y, 所有w, 所有h, 所有class0, ...]
            const validDetections = [];
            
            for (let i = 0; i < Math.min(detections, 100); i++) { // 只检查前100个
                const x = data[0 * detections + i];
                const y = data[1 * detections + i];
                const w = data[2 * detections + i];
                const h = data[3 * detections + i];
                
                // 检查坐标合理性
                if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && w > 0 && w <= 1 && h > 0 && h <= 1) {
                    let maxScore = 0;
                    let maxClass = 0;
                    
                    for (let c = 0; c < 7; c++) {
                        const score = data[(4 + c) * detections + i];
                        if (score > maxScore) {
                            maxScore = score;
                            maxClass = c;
                        }
                    }
                    
                    if (maxScore > 0.01) {
                        validDetections.push({
                            index: i,
                            bbox: { x, y, w, h },
                            class: maxClass,
                            confidence: maxScore
                        });
                    }
                }
            }
            
            return {
                validDetections: validDetections.length,
                samples: validDetections.slice(0, 5)
            };
        }
        
        function parseMethod2(data, features, detections) {
            // 按检测排列: [det0的所有特征, det1的所有特征, ...]
            const validDetections = [];
            
            for (let i = 0; i < Math.min(detections, 100); i++) {
                const baseIdx = i * features;
                const x = data[baseIdx + 0];
                const y = data[baseIdx + 1];
                const w = data[baseIdx + 2];
                const h = data[baseIdx + 3];
                
                if (x >= 0 && x <= 1 && y >= 0 && y <= 1 && w > 0 && w <= 1 && h > 0 && h <= 1) {
                    let maxScore = 0;
                    let maxClass = 0;
                    
                    for (let c = 0; c < 7; c++) {
                        const score = data[baseIdx + 4 + c];
                        if (score > maxScore) {
                            maxScore = score;
                            maxClass = c;
                        }
                    }
                    
                    if (maxScore > 0.01) {
                        validDetections.push({
                            index: i,
                            bbox: { x, y, w, h },
                            class: maxClass,
                            confidence: maxScore
                        });
                    }
                }
            }
            
            return {
                validDetections: validDetections.length,
                samples: validDetections.slice(0, 5)
            };
        }
        
        window.addEventListener('load', analyzeYOLOFormat);
    </script>
</body>
</html>